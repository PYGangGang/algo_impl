# 散列表 / hash table / hash fuction / 哈希表 / 哈希冲突 / collision / 完美哈希 / perfect hash

哈希表是一个将 key 映射到 value 的数据结构，它提供平均情况下O(1)的 Search（查找）、Insert（插入）、Delete（删除）功能。

---

[1] 实现哈希表的方法

* 直接寻址表
    * 若可能的 key 的集合为 U ，大小为 n ，我们直接用一个大小为 n 的数组来储存所有的元素（或者指向元素的指针），没有使用的 slot 则用特殊标识符占位；通过直接的随机访问，我们可以轻松的实现各种功能
    * 这会占用 n 的空间；若实际使用的 key 的数量远小于 n （这是普遍情况）；这会非常占用空间
    * 但是某些情况下，我们用这种方式来使用哈希的思想，如 [leetcode #448](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

* 粗糙哈希表
    * 我们用一个大小为 m 的数组来储存所有元素，使用一个哈希函数 h(key) 来将元素映射到 [0, m - 1] 的空间里
        * 除法哈希函数
            * 我们直接用 key 对 m 取模，即 h(key) = key mod m;
            * 此时应该注意 m 的取值；如 m = 2^p 时，取模的结果即为 key 的最低的 p 位数字，其他位的数值并没有为哈希的结果做出贡献（这是我们不希望看到的）
            * 一般的，我们选取 m 为一个不太接近 2 的整数幂的数
        
        * 乘法哈希函数
            * 我们将 key 乘上一个 A ∈ (0, 1)，取其小数部分乘上 m 后向下取整，即 h(key) = ⌊m * (key * A mod 1)⌋
            * 该方法对 m 和 A 的选取都没有特别的要求；但是 m 建议取 2^p， A 建议取 0.618 详见《算法导论》 11.3.2
        
        * <span style="background-color: #ffaaaa">全域哈希函数（universal hashing）</span>
            * 每次计算哈希值时，我们从一个哈希函数集合 H 中

[2] 解决冲突的设计

* 链表法
    * 大小为 m 的数组里存放了指向该哈希值对应的元素链表，当发生冲突时，我们将元素插入到该链表的头节点之前
    * 链表一般设计为双向链表，因为其删除时间复杂度为 O(1)

* 开放寻址法
    * 我们在大小为 m 的数组中直接储存元素，使用发生冲突时跳过当前 slot 继续向前的方式避免冲突
    * 跳过的方式不能是简单的 ++，这样的效率太低，我们加入探查参数 i  ∈ U来标识需要探查的序列的不同；哈希函数被扩展为 h(key, i) 来确定我们下次探查的 slot
        * 插入：通过 h(key, 0) 来确认探查的初始位置，若该位置已经被占用，则探查 h(key, 1)；如此重复执行直到找到空 slot
        * 查找：因为某个 key 的可能存在位置，由 h(key, i) 产生的序列决定，并总是在第一个空位插入，所以我们顺序检查该序列，若找到了目标则返回 true ，第一次遇到空 slot 则返回 false
        * 删除：直接按照查找的方式直接删除某个 slot 中的元素不可行；当插入元素 k 时，发现 slot j 被占用了，我们直接跳过了 j 将 k 插入到了序列中后面的某个位置；在我们删除了 j 处的元素后，再次查找 k 时一定会先探查到 j 为空，则直接返回了 false；所以，我们用类似 DELETED 的标识符，来表示该元素已经被删除，而非直接删除它
            * 此时，Load Factor 不再能表示哈希表中的实际元素数量，所以，通常在需要删除的应用中，我们更多地使用链表法实现
    
    * 均匀哈希假设（uniform hashing）：假设我们的哈希函数能够使得每个 key 对应的探查序列等可能的为 {1, ... , m} 的 m! 种排列中的一种；实际上这个假设几乎不可能实现，我们用以下的近似方法来逼近
        * 线性探查（只有 m 种序列）
            * 通过每次 ++i 的方式，顺序探查整个序列，即 h(key, i) = (h_norm(key) + i) mod m；h_norm(key)为一个普通的哈希函数
            * 随着元素的不断插入，该方法会导致连续占用的 slot 越来越多，从探查的元素越来越多
        
        * 二次探查（同只有 m 种序列）
            * 不是单纯 ++i ，而是加上一个 i 的二次方数，即 h(key, i) = (h_norm(key) + c1 * i + c2 * i^2) mod m
            * 虽然这种方式解决了 slot 的连续占用问题，但是对于 h_norm(key) 相同的元素，它们的探查序列完全一样，并也只用到了 m 种序列
            * 系数 c1 和 c2 的设计需要详细考虑
        
        * 双重哈希（double hashing）
            * 不是单纯的在给 i 加上一个定系数，而是给 i 乘上一个与 key 相关的哈希函数，即 h(key, i) = (h1(key) + i * h2(key)) mod m
            * 除非某两个 key 的 h1 和 h2 的值都相同，否则它们的探查序列注定不相同

* 完美哈希（perfect hashing）
    * 可以理解为一个综合了链表法和开放寻址法的哈希表；它的构成为：先用 h1(key) 函数，将元素映射到大小为 n 的主哈希表上；主哈希表每个 slot 跟了一个二级哈希表，再用 h2(key) 函数映射到二级哈希表中存放
    * 这种方法达到 O(1) 复杂度的前提是：所有可能的 key 的集合在存入哈希表之后，便不再变化
    * 《算法导论》11.5 中详细证明了，当我们把处在主哈希表 slot j 上的二级哈希表的大小设置为可能映射到该 slot 的 key 的数量 nj 的平方时，即 nj^2；期望的总存储空间为 2n，即 E[Σnj^2] < 2n；而其大于 4n （4n以上我们认为是非线性）的概率小于 1/2

* 特殊情况下的衍生方法
    * 线性哈希表（linear hashing）
    * 一致性哈希（consistent hashing）introduced by David Karger et al. at MIT
        * 在分布式系统场景中，假设我们有 n 个缓存服务器，我们需要把不同的元素均匀地存到服务器中；自然地，我们会想到用哈希算法（如 h(key) = key mod n），来将元素映射到这 n 个服务器上。但是，当我们删除或增加服务器节点时，由于 n 发生变化，所有已存储元素的哈希值都发生了变化，此时我们就需要将所有元素做一次 rehash ，重新存入新的目标服务器；而一致性哈希就是为了减少 rehash 次数而被提出的；我们假想 0 -> 2^32 - 1 首尾相接构成的一个圆，首先将所有元素映射到这个圆上（ say 简单的哈希函数 h(key) = key mod 2^32 ），然后将服务器映射到这个圆上（ say 用 ip 或机器名作 key ），最后以顺时针方向，将每个元素存到离他最近的服务器上；当扩缩容时，即增减服务器，我们只需要挪动增加的节点的后一个节点上的部分元素，或删除的节点上的所有元素，即可。因为哈希值不会发生变化；
        *
    
    * F14 和 B16 哈希

[3]一些实现上的细节

* 哈希函数的设计
* Load Factor 和哈希表的扩缩容
* STL 中 unordered_map 的实现
* Java 中 HashMap 的实现
